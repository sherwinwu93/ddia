# 2 Data Models and Query Languages 数据模型和查询语言
Data models affect how we think about the problem.

这一层的数据模型抽象更底层:eg
1. 用对象模型表示真实世界, 用API操作这些数据结构
2. 用通用的数据模型, JSON~XML,关系数据库表~图模型 存储这些数据结构
3. 数据库软件用内存~硬盘~网络中的bytes表示JSON/XML/relational/graph data
4. 更底层用电流~磁场来表示字节

虽然这一层用干净的数据结构抽象了更下层,但是有些好用,有些难用

:wusd
relational, document, graph, and their cases

## Relational Model Versus Document Model
关系型: 数据库表和行
用途: transaction processing, batch processing
很多扬言要取代关系型数据库,但是它挺到现在

## The Birth of NoSQL
NoSQL->Not Only SQL
NoSQL的动力:
1. 处理大量数据
2. 对免费开源的偏好
3. 有些模型不被Relational支持
4. 大量变化的数据模型(Relational很严格)

## The Object-Relational Mismatch
对象和关系型数据库的不匹配, 产生了ORM(但是也没完全解决分歧)
1对1的放一张表
1对多的多种方式:
1. 主表存其他表的外键
2. 单表支持结构化的多个值
3. 把这些转成JSON存储到单行,不支持结构化的查询
直接搞成Document(JSON, tree),存储到mongodb

## Many-to-one and Many-to-Many Relationships
为什么用region_id和industry_id,而不是直接用Greater Seattle Area和Philanthropy
1. 一致style和拼写
2. 避免歧义(不同地方相同名称)
3. 便于修改(一次修改,全部生效)
4. 更便于支持国际化
5. 便于搜索, 比如搜索杭州, 上城区也在其中
任何对人类有意义的数据,都有可能修改, id只对数据库有意义,不会改变
这种多对一的关系,适用于relational,但不适用document.如果用document,就需要在apps里面做jion

profile的变化:
1. Organization和Schools变为实体,不再只是text
2. Recommendation: Profile显示其推荐人(带简要信息)

解决方案:
部分document,部分relation.

多对多: 一个profile多个schoolId,对应多个school

## Are Document Databases Repeating History?

### The relation model
关系型: 表和行,没了
只需要写好查询优化器,所有查询都会受益

### Comparison to document databases
多对一,多对多适合关系型, 一对多适合document

## Relational Versus Document Databases Today
document data model结构弹性,性能更好,更符合数据结构
relational data model提供更好的joins,多对一和多对多的关系

### Which data model leads to simpler application code?
取决于应用本身,相互间关系越少越适合relational,graph

### Schema flexibility in the document model
document model并不是schemaless, 而是 schema on read(像反射), relational是schema on write(像普通编程).

把name拆成first_name和last_name:
- document: 新文档创建时,用新字段; 当读取的时候, 把旧文档数据拆分
- relational: 增加字段, 更新新字段的值(如果太慢的话,采取第一种方法)

schema-on-read 好处:
- 对象类型多样,不适合都放各自的表中
- 数据来自于外部系统,没法控制,可能一直会变

### Data locality for queries
document的限制: 如果只需要一小部分,那么会很浪费.如果经常要更新,性能比较差.
Oracle的multi-table index cluster tables, 可以把相关联的数据放一起,产生locality

### Convergence of document and relational databases

## Query Languages for Data
是declarative的, 只要求结果,不关注怎么做到. 让database自己去优化查询,自己去并行处理...

## Declarative Queries on the Web

## MapReducing Query
MapReducing:
    - 在不同机器上批量处理大规模数据,MongoDB(read-only跨文档)
    - 既不是声明式,也不是祈使式的. 建立在map和reduce functions(许多函数式语言支持)
    - map,reduce只能纯function,不能有副作用

eg: 海洋学家每个月看到多少鲨鱼
```sql
select data_trunc('month', observation_timestamp) as observation_month,
       sum(num_animals) as total_animals from observatons
       where family= 'Sharks'
       group by observation_month;
```
# mongodb
```javascript
db.observations.mapReduce(
  function map() {
    var year = this.observation_timestamp.getFullYear();
    var month = this.observation_timestamp.getMonth() + 1;
    emit(year + '-' + month, this.num_animals);
  }
  function reduce(key, values) {
      return Array.sum(values);
  },
{
    query : {family: 'Sharks'},
    out : 'shark_monthly_counts'
}
)
```

## Graph-Like Data Models

## Property Graphs

## The Cypher Query Language

## Graph Queries in SQL

## Triple-Stores and SPARQL

## The Foundation: Datalog

## Summary
big tree->relational model->no sql(document model, graph model)
examples: SQL~MapReduce~MongoDB~Cypher~SPARQL~Datalog
