# 2 Data Models and Query Languages 数据模型和查询语言
Data models affect how we think about the problem.

这一层的数据模型抽象更底层:eg
1. 用对象模型表示真实世界, 用API操作这些数据结构
2. 用通用的数据模型, JSON~XML,关系数据库表~图模型 存储这些数据结构
3. 数据库软件用内存~硬盘~网络中的bytes表示JSON/XML/relational/graph data
4. 更底层用电流~磁场来表示字节

虽然这一层用干净的数据结构抽象了更下层,但是有些好用,有些难用

:wusd
relational, document, graph, and their cases

## Relational Model Versus Document Model
关系型: 数据库表和行
用途: transaction processing, batch processing
很多扬言要取代关系型数据库,但是它挺到现在

## The Birth of NoSQL
NoSQL->Not Only SQL
NoSQL的动力:
1. 处理大量数据
2. 对免费开源的偏好
3. 有些模型不被Relational支持
4. 大量变化的数据模型(Relational很严格)

## The Object-Relational Mismatch
对象和关系型数据库的不匹配, 产生了ORM(但是也没完全解决分歧)
1对1的放一张表
1对多的多种方式:
1. 主表存其他表的外键
2. 单表支持结构化的多个值
3. 把这些转成JSON存储到单行,不支持结构化的查询
直接搞成Document(JSON, tree),存储到mongodb

## Many-to-one and Many-to-Many Relationships
为什么用region_id和industry_id,而不是直接用Greater Seattle Area和Philanthropy
1. 一致style和拼写
2. 避免歧义(不同地方相同名称)
3. 便于修改(一次修改,全部生效)
4. 更便于支持国际化
5. 便于搜索, 比如搜索杭州, 上城区也在其中
任何对人类有意义的数据,都有可能修改, id只对数据库有意义,不会改变
这种多对一的关系,适用于relational,但不适用document.如果用document,就需要在apps里面做jion

profile的变化:
1. Organization和Schools变为实体,不再只是text
2. Recommendation: Profile显示其推荐人(带简要信息)

解决方案:
部分document,部分relation.

多对多: 一个profile多个schoolId,对应多个school

## Are Document Databases Repeating History?

### The relation model
关系型: 表和行,没了
只需要写好查询优化器,所有查询都会受益

### Comparison to document databases
多对一,多对多适合关系型, 一对多适合document

## Relational Versus Document Databases Today
document data model结构弹性,性能更好,更符合数据结构
relational data model提供更好的joins,多对一和多对多的关系

### Which data model leads to simpler application code?
取决于应用本身,相互间关系越少越适合relational,graph

### Schema flexibility in the document model
document model并不是schemaless, 而是 schema on read(像反射), relational是schema on write(像普通编程).

把name拆成first_name和last_name:
- document: 新文档创建时,用新字段; 当读取的时候, 把旧文档数据拆分
- relational: 增加字段, 更新新字段的值(如果太慢的话,采取第一种方法)

schema-on-read 好处:
- 对象类型多样,不适合都放各自的表中
- 数据来自于外部系统,没法控制,可能一直会变

### Data locality for queries
document的限制: 如果只需要一小部分,那么会很浪费.如果经常要更新,性能比较差.
Oracle的multi-table index cluster tables, 可以把相关联的数据放一起,产生locality

### Convergence of document and relational databases

## Query Languages for Data
是declarative的, 只要求结果,不关注怎么做到. 让database自己去优化查询,自己去并行处理...

## Declarative Queries on the Web

## MapReducing Query
MapReducing:
    - 在不同机器上批量处理大规模数据,MongoDB(read-only跨文档)
    - 既不是声明式,也不是祈使式的. 建立在map和reduce functions(许多函数式语言支持)
    - map,reduce只能纯function,不能有副作用

eg: 海洋学家每个月看到多少鲨鱼
```sql
select data_trunc('month', observation_timestamp) as observation_month,
       sum(num_animals) as total_animals from observatons
       where family= 'Sharks'
       group by observation_month;
```
# mongodb
```javascript
db.observations.mapReduce(
  function map() {
    var year = this.observation_timestamp.getFullYear();
    var month = this.observation_timestamp.getMonth() + 1;
    emit(year + '-' + month, this.num_animals);
  }
  function reduce(key, values) {
      return Array.sum(values);
  },
{
    query : {family: 'Sharks'},
    out : 'shark_monthly_counts'
}
)
```

## Graph-Like Data Models
可以建模为graph的数据:算法最短路径,PageRank
- Social graphs: 社交图
- The Web graph: 网络图
- Road or rail network: 路线网络或铁路网络

model:
- property graph: Neo4j,Titan,InfiniteGraph
- triple-store: Datomic, AllegroGraph
language: Cypher~SPARQL~Datalog(declarative), Gremlin(imperative)
framework: Pregel

## Property Graphs
vertex consists of:
- id
- 出的边集合
- 入的边集合
- 属性值集合

edge consists of:
- id
- 边起始点(tail)
- 边开始点(head)
- 边的label
- 边的属性值集合

-- SQL表示vertex和edge
```sql
CREATE TABLE vertices (
                          vertex_id   integer PRIMARY KEY,
                          properties  json
);
CREATE TABLE edges (
                       edge_id
                                   integer PRIMARY KEY,
                       tail_vertex integer REFERENCES vertices (vertex_id),
                       head_vertex integer REFERENCES vertices (vertex_id),
                       label
                                   text,
                       properties  json
);
CREATE INDEX edges_tails ON edges (tail_vertex);
CREATE INDEX edges_heads ON edges (head_vertex);
```
1. 任两vertex都可以用edge相连,没有限制
2. 任何vertex都有incoming edges和outgoing edges,可以快速遍历vertices集合,无论正向反向
3. 可以存储不同的信息在graph里,仍然维持干净的数据模型

## The Cypher Query Language
```Cypher
CREATE
  (NAmerica:Location {name:'North America', type:'continent'}),
  (USA:Location      {name:'United States', type:'country'  }),
  (Idaho:Location    {name:'Idaho',         
type:'state'
  (Lucy:Person       {name:'Lucy' }),
  (Idaho) -[:WITHIN]->  (USA)  -[:WITHIN]-> (NAmerica),
  (Lucy)  -[:BORN_IN]-> (Idaho)
```
example: 找出所有从美国移民到欧洲的人(找含有born_in(US)的且含有living_in(EU)的顶点,返回顶点的名称属性)
cypher:
    MATCH
        (person) -[:BORN_IN]->  () -[:WITHIN*0..]-> (us:Location {name:'United States'}),
        (person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})
    RETURN person.name

## Graph Queries in SQL
```sql
WITH RECURSIVE
    -- in_usa is the set of vertex IDs of all locations within the United States
    in_usa(vertex_id) as (
        select vertex_id from vertices where properties->>'name' = 'United States'
        union
            select edges.tail_vertex from edges
                join in_usa on edges.head_vertex = in_usa.vertex_id
                where edges.label = 'within'
    ),
    -- in_europe is the set of vertex IDs of all locations within Europe
    in_europe(vertex_id) as (
        select vertex_id from vertices where properties->>'name' = 'Europe'
        union
            select edges.tail_vertex from edges
                join in_europe on edges.head_vertex = in_europe.vertex_id
                where edges.label = 'within'
    ),
    -- born_in_usa is the set of vertex IDs of all people born in the US
    born_in_usa(vertex_id) as (
        select edges.tail_vertex from edges
            join in_usa on edges.head_vertex = in_usa.vertex_id
            where edges.label = 'born_in'
    ),
    -- born_in_usa is the set of vertex IDs of all people living in Europe
    lives_in_europe(vertex_id) as (
        select edges.tail_vertex from edges
            join in_europe on edges.head_vertex = in_europe.vertex_id
            where edges.label = 'lives_in'
    )
    select vertices.properties->>'name'
    from vertices
    -- join to find those people who were both born in the US *and* live in Europe
    join born_in_usa on vertices.vertex_id = born_in_usa.vertex_id
    join lives_in_europe on vertices.vertex_id = lives_in_europe.vertex_id;
```
1. 找出United States的vertexId,再递归找对应edges(label:with_in,head_vertex:in_usa)中vertexId.
   这样递归找出了美国的所有地区 in_usa
2. 同理找出欧洲的所有地区 in_europe
3. 找edges中label是born_in,且head_vertex是in_usa的
   找出所有在美国出生的人 born_in_usa
4. 同理找出所有在欧洲居住的人 lives_in_europe
5. join born_in_usa, lives_in_europe找出所有在美国出生,欧洲居住的人.即移民到美国的欧洲人


## Graph Queries in SQL

## Triple-Stores and SPARQL

## The Foundation: Datalog

## Summary
big tree->relational model->no sql(document model, graph model)
examples: SQL~MapReduce~MongoDB~Cypher~SPARQL~Datalog
