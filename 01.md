# 01 Reliable, Scalable, and Maintainable Applications
Reliability: 系统正常工作,并且对用户隐藏错误类型
Scalability: 高负载是系统正常工作, 指标: load, response time percentiles
Maintainability: 开发要减少复杂度,运维要可视

app's functionalities:
- 读写数据(databases)
- 缓存昂贵操作结果(caches)
- 关键字查询(search indexes)
- 发送消息,异步处理(stream processing)
- 周期性聚合大数据(batch processing)

:wusd
学会用不同数据系统的特性,实现reliable,scalable,maintainable的应用

## Thinking About Data Systems
database,MQ都存储数据,但是访问方式不同,特性不同,实现不同.
为什么叫他们数据系统?
很多Data System不能简单分类: 像Redis也当队列用,Kafka也持久化
很多应用这些DataSystem都结合使用,满足需求.
比如: 项目有memcached和ES,Postgresql. 项目的职责就是确保memcached,ES和pgsql的数据一致.
[./databasesystem.png]
..
tricky questions:
1. 如何在有内部错误的情况下,保证数据正确且完整
2. 如何在系统部分恶化的情况下,维持好的性能
3. 如何在负载增加时,扩展
4. 好的API应该怎么样
-----
影响系统设计的因素:
- 成员的技能和经验
- 历史系统依赖
- 发布时间
- 组织对于错误类型的容忍度
- 监管限制
...
## Reliability
typical expectations: continuing to work correctly, even when things go wrong
- 按用户预期工作
- 容忍用户输入错误,和错误的使用方式
- 在期望的负载和数据量时,性能符合预期
- 避免未认证的访问,滥用

只能容忍部分类型的fault,就已经是reliable了
fault是不符合标准,failure是程序挂了
反直觉的,频繁故意触发错误,反而能让你正确处理这些错误
倾向于容忍错误(cured),而不是避免错误(prevention).

## Hardware Faults

## Software Errors
..
软件异常通常是相干的
- 软件异常造成所有实例宕机
- 失控的进程耗尽CPU~内存~磁盘~带宽
- 下游运行慢,拖累上游系统
- 雪崩

有帮助的方式:
- 正确预估和在系统交互
- 测试
- 进程隔离
- 运行进程销毁和重启
- 测量与监控
- 分析系统在生产的行为
- 比如: message queue,可以对下incoming message和outgoing message的数量

## Human Errors
配置错误是宕机的主要原因.
避免人为错误的方法:
- 用减少错误的方式设计系统: 比如: 良好的抽象,APIs,管理界面(但是如果限制太多,人们就会绕开它)
- 沙盒, 用真实的生产数据去测试
- 单元测试,集成测试,指引测试.自动化测试(对边界尤其好)
- 允许简单的方式恢复数据. 比如: 回退配置修改,回退代码, 提供工具去修复数据
- 搭建详尽且清除的监控,性能指标和错误率
- 实现良好的管理和训练(训练人员?)

## How Important Is Reliability?

## Scalability
Scalability: system's ability to cope with increased load

## Describing Load
load parameters: 以下都可能是指标.可能平均情况很重要,但瓶颈却是那种极端情况
- requests per second
- ratio of reads to writes
- number of active users
- hit rate on a cache

Twitter's Example:
Post tweet: 4.6k requests/sec on average, over 12k requests/sec at peak
Home timeline: 300k requests/sec

Solutions:
1. a global collection of tweets
2. push message to a mailbox of every recipient user

## Describing Performance
看performance的两种方式:
1. 增加负载后,对系统性能的影响
2. 增加负载后,需要增加多少资源才能保持性能不变

throughput:(hadoop) 单位时间处理的记录数,或者处理一定数据的时间
response time:(web) 单位时间处理一个请求所花费的时间, (看值分布,而不是单一值)
    - 指标:
      + mean: 总时间除以请求数(适合)
      + average: 一半的请求小于这个时间,一半请求大于这个时间(适合)
      + 99th percentiles: 99%的请求处理时间小于这个值(适合)
    - 影响因素:
      + 进程转为后台运行
      + 网络包丢失,TCP转换
      + GC
      + 磁盘I/O, 服务器机房震动
    - 实例: 亚马逊要求99.9th percentiles,慢的用户是因为买的东西多,是最有价值的用户.每多100ms减少1%的销量
SLAs: median response time<200ms, 99th percentiles <1s, 99.9%的时间要满足
response time: 可能单个进程处理得很快,但是并行量不大,出现 head-of-line blocking.
tail latency amplification: 多个线程并行,只要有一个线程慢,就会导致整体性能下降.

## Approaches for Coping with Load
适合当前体量的架构不一定适合10倍体量的数据,每次负载增加时,都需要重新考虑架构.
scaling up: vertical scaling,增加硬件资源
scaling out: horizontal scaling,增加实例

elastic vs manually: 云是根据负载自动扩容(复杂),手动扩容需要人工操作(简单).
stateful data systems从单点到分布式会引入很多复杂性.最好是先垂直扩容数据库,逼不得已才水平扩容.

影响架构的因素: 读量,写量,存储量,数据复杂度,response time要求,访问形式
架构设计要考虑哪些是主要操作,哪些是很少的操作.可能频繁迭代,比提前考虑未来的扩容更重要.

## Maintainability
Avoid creating legacy software ourselves:
- Operability: 可运营的
- Simplicity: 让新人能快速上手,尽可能简单(但不是减少功能)
- Evolvability: 容易扩展,适应需求变更(兼容未出现的用例)

## Operability: Making Life Easy for Operations

## Simplicity: Managing Complexity
Complexity:
- 状态量爆炸
- 模块间紧密耦合
- 复杂依赖
- 不一致的命名和术语
- 用于改善性能的后门
- 绕过issue的特殊用例
变更时引入bug:
- 逻辑太复杂
- 隐藏的假设
- 未知的结果
- 意外的交互行为
Complexity定义: 意外的复杂性,只要不是问题固有的,而是实现引入的
abstraction: 解决complexity,不单单是简单复用,而是让所有使用的系统都受益
    通过良好的抽象,把大系统变成良好定义~复用的模块

## Evolvability: Making Change Easy
Agile techniques: TDD, refactoring
敏捷技术用于小范围本地的变化, Evolvability作用于整个系统

## Summary






